/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/CD_header_v1.glb 
*/

import React, {
  forwardRef,
  useRef,
  useImperativeHandle,
  useEffect,
} from "react";
import { useGLTF } from "@react-three/drei";
import gsap from "gsap";
import * as THREE from "three";
export const Header_v1 = forwardRef((props, ref) => {
  const { nodes, materials } = useGLTF(
    "src/models/CD_header_v1-transformed.glb"
  );
  const groupRef = useRef();
  const goldMeshRefs = useRef([]);
  const whiteMeshRefs = useRef([]);
  const timelineGoldRef = useRef(null);
  const timelineWhiteRef = useRef(null);

  // // Setup gold and white materials for animation (if not already)
  // useEffect(() => {
  //   if (materials.gold) {
  //     materials.gold.emissive = materials.gold.emissive || { r: 0, g: 0, b: 0 };
  //     materials.gold.emissiveIntensity = 0.5;
  //   }
  //   if (materials.white) {
  //     materials.white.emissive = materials.white.emissive || { r: 0, g: 0, b: 0 };
  //     materials.white.emissiveIntensity = 0.5;
  //   }
  // }, [materials]);

  // useImperativeHandle(ref, () => ({
  //   // Gold group controls
  //   showGold: () => {
  //     const reversedRefs = [...goldMeshRefs.current].reverse();
  //     reversedRefs.forEach((mesh, index) => {
  //       if (mesh) {
  //         const delay = index * 0.08;
  //         gsap.to(mesh.scale, {
  //           x: 1,
  //           y: 1,
  //           z: 1,
  //           duration: 0.5,
  //           delay,
  //           ease: "elastic.out(1, 0.3)",
  //         });
  //       }
  //     });
  //   },
  //   hideGold: () => {
  //     goldMeshRefs.current.forEach((mesh) => {
  //       if (mesh) {
  //         gsap.to(mesh.scale, {
  //           x: 0,
  //           y: 0,
  //           z: 0,
  //           duration: 0.3,
  //           ease: "power2.in",
  //         });
  //       }
  //     });
  //   },
  //   setGoldEmissiveIntensity: (intensity = 0.5) => {
  //     goldMeshRefs.current.forEach((mesh) => {
  //       if (mesh && mesh.material) {
  //         gsap.to(mesh.material, {
  //           emissiveIntensity: intensity,
  //           duration: 0.5,
  //         });
  //       }
  //     });
  //   },
  //   // White group controls
  //   showWhite: () => {
  //     const reversedRefs = [...whiteMeshRefs.current].reverse();
  //     reversedRefs.forEach((mesh, index) => {
  //       if (mesh) {
  //         const delay = index * 0.08;
  //         gsap.to(mesh.scale, {
  //           x: 1,
  //           y: 1,
  //           z: 1,
  //           duration: 0.5,
  //           delay,
  //           ease: "elastic.out(1, 0.3)",
  //         });
  //       }
  //     });
  //   },
  //   hideWhite: () => {
  //     whiteMeshRefs.current.forEach((mesh) => {
  //       if (mesh) {
  //         gsap.to(mesh.scale, {
  //           x: 0,
  //           y: 0,
  //           z: 0,
  //           duration: 0.3,
  //           ease: "power2.in",
  //         });
  //       }
  //     });
  //   },
  //   setWhiteEmissiveIntensity: (intensity = 0.5) => {
  //     whiteMeshRefs.current.forEach((mesh) => {
  //       if (mesh && mesh.material) {
  //         gsap.to(mesh.material, {
  //           emissiveIntensity: intensity,
  //           duration: 0.5,
  //         });
  //       }
  //     });
  //   },
  //   // Shared controls
  //   moveUp: (z = 0) => {
  //     if (groupRef.current) {
  //       gsap.to(groupRef.current.position, {
  //         y: groupRef.current.position.y + z,
  //         duration: 2,
  //         ease: "power2.out",
  //       });
  //     }
  //   },
  //   getGroupRef: () => groupRef.current,
  // }));

  // // Animation setup for gold and white (optional, can be expanded)
  // useEffect(() => {
  //   if (goldMeshRefs.current.length) {
  //     gsap.killTweensOf(goldMeshRefs.current);
  //     goldMeshRefs.current.forEach((mesh) => {
  //       if (mesh) {
  //         gsap.set(mesh.scale, { x: 1, y: 1, z: 1 });
  //         gsap.set(mesh.rotation, { x: 0, y: 0, z: 0 });
  //       }
  //     });
  //   }
  //   if (whiteMeshRefs.current.length) {
  //     gsap.killTweensOf(whiteMeshRefs.current);
  //     whiteMeshRefs.current.forEach((mesh) => {
  //       if (mesh) {
  //         gsap.set(mesh.scale, { x: 1, y: 1, z: 1 });
  //         gsap.set(mesh.rotation, { x: 0, y: 0, z: 0 });
  //       }
  //     });
  //   }
  // }, []);

  // Render all meshes and collect refs
  return (
    // <group {...props} dispose={null}>
    //   <mesh geometry={nodes.Gold_International.geometry} material={materials.gold} rotation={[Math.PI / 2, 0, 0]} />
    //   <mesh geometry={nodes.WhiteFont_OnTop.geometry} material={materials.white} position={[-0.261, 0.058, 0.004]} rotation={[Math.PI / 2, 0, 0]} />
    // </group>
    <group {...props} dispose={null} ref={groupRef}>
      {Object.keys(nodes)
        .filter((key) => key.startsWith("Gold_") || key.startsWith("R_"))
        .map((key, i) => (
          <mesh
            key={key}
            ref={(el) => (goldMeshRefs.current[i] = el)}
            geometry={nodes[key].geometry}
            material={materials.gold}
            position={nodes[key].position}
            rotation={nodes[key].rotation}
          />
        ))}

      {Object.keys(nodes)
        .filter(
          (key) =>
            key.startsWith("WhiteFont_") ||
            key.startsWith("OriginalCurveInternationalWHITE_")
        )
        .map((key, i) => (
          <mesh
            key={key}
            ref={(el) => (whiteMeshRefs.current[i] = el)}
            geometry={nodes[key].geometry}
            material={materials.white}
            // material={
            //   new THREE.MeshStandardMaterial({
            //     color: "white",
            //     emissive: "white",
            //     emissiveIntensity: 0.5,
            //   })
            // }
            rotation={nodes[key].rotation}
            position={nodes[key].position}
          />
        ))}
    </group>
  );
});

useGLTF.preload("src/models/CD_header_v1-transformed.glb");
