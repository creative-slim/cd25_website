/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/earthv4_UV.glb --transform
Files: ./public/earthv4_UV.glb [356.76KB] > /Users/slim-cd/Documents/_Projects/__Creative Directors Website/website 2025/react-3D/cd25_website/earthv4_UV-transformed.glb [30.93KB] (91%)
*/

import React, { useRef, useMemo, useEffect } from "react"; // Import useEffect
import { useGLTF, useTexture, shaderMaterial } from "@react-three/drei"; // Import shaderMaterial
import { useFrame, extend } from "@react-three/fiber"; // Import extend
import * as THREE from "three";
import { Suspense } from "react";
import { forwardRef, useImperativeHandle } from "react";
import { useControls } from "leva"; // Import useControls

// Determine the model URL based on the environment
const isDevelopment = import.meta.env.DEV;
const localModelUrl = "src/models/earth_final-transformed.glb";
const remoteModelUrl =
  "https://files.creative-directors.com/creative-website/creative25/glbs/earth_final-transformed.glb"; // Corrected remote URL if needed
const modelUrl = isDevelopment ? localModelUrl : remoteModelUrl;

console.log(`Loading model from: ${modelUrl}`); // Log which URL is being used

// Define the shaders
const vertexShader = `
  uniform float uTime;
  uniform float uWaveIntensity; // Overall intensity/amplitude
  uniform float uWaveFrequency; // Base spatial frequency
  uniform float uWaveSpeed;     // Overall speed

  varying vec2 vUv;
  varying float vWaveHeight;

  // Function to calculate a single directional wave
  float getWave(vec2 position, float time, vec2 direction, float frequency, float amplitude, float speed) {
    float angle = dot(direction, position);
    return amplitude * sin(angle * frequency + time * speed);
  }

  void main() {
    vUv = uv;
    vec3 pos = position;
    float totalDisplacementY = 0.0;

    // Layer 1: Large swells
    vec2 dir1 = normalize(vec2(1.0, 0.6)); // Adjusted direction
    float amp1Mult = 1.0;
    float freq1Mult = 0.8; // Slightly lower frequency for broader swells
    float speed1Mult = 0.6;
    totalDisplacementY += getWave(pos.xz, uTime, dir1, uWaveFrequency * freq1Mult, uWaveIntensity * amp1Mult, uWaveSpeed * speed1Mult);

    // Layer 2: Medium, choppier waves
    vec2 dir2 = normalize(vec2(0.5, -0.9)); // Adjusted direction
    float amp2Mult = 0.6;
    float freq2Mult = 1.8; // Adjusted frequency
    float speed2Mult = 0.9;
    totalDisplacementY += getWave(pos.xz, uTime, dir2, uWaveFrequency * freq2Mult, uWaveIntensity * amp2Mult, uWaveSpeed * speed2Mult);

    // Layer 3: Small, faster ripples
    vec2 dir3 = normalize(vec2(-0.7, 0.7)); // Adjusted direction
    float amp3Mult = 0.35;
    float freq3Mult = 3.5; // Adjusted frequency
    float speed3Mult = 1.2;
    totalDisplacementY += getWave(pos.xz, uTime, dir3, uWaveFrequency * freq3Mult, uWaveIntensity * amp3Mult, uWaveSpeed * speed3Mult);

    // Layer 4: Very fine, quick surface noise/ripples
    vec2 dir4 = normalize(vec2(-0.9, -0.3)); // New direction
    float amp4Mult = 0.15; // Smaller amplitude
    float freq4Mult = 7.0;  // Higher frequency
    float speed4Mult = 1.8; // Faster speed
    totalDisplacementY += getWave(pos.xz, uTime, dir4, uWaveFrequency * freq4Mult, uWaveIntensity * amp4Mult, uWaveSpeed * speed4Mult);

    pos.y += totalDisplacementY;

    // Normalize wave height for coloring
    // Sum of amplitude multipliers: 1.0 + 0.6 + 0.35 + 0.15 = 2.1
    float totalMaxAmplitude = uWaveIntensity * (amp1Mult + amp2Mult + amp3Mult + amp4Mult);
    if (totalMaxAmplitude == 0.0) { // Avoid division by zero if intensity is zero
        vWaveHeight = 0.5;
    } else {
        vWaveHeight = (totalDisplacementY / totalMaxAmplitude) * 0.5 + 0.5;
    }
    vWaveHeight = clamp(vWaveHeight, 0.0, 1.0);

    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

const fragmentShader = `
  uniform vec3 uLowColor;
  uniform vec3 uHighColor;
  varying vec2 vUv;
  varying float vWaveHeight;

  void main() {
    // Mix colors based on wave height
    vec3 mixedColor = mix(uLowColor, uHighColor, clamp(vWaveHeight, 0.0, 1.0));
    gl_FragColor = vec4(mixedColor, 1.0);
  }
`;

// Create a custom material using shaderMaterial
const WaterMaterial = shaderMaterial(
  {
    uTime: 0,
    uLowColor: new THREE.Color(0xc1e0ff), // Default Dark blue for troughs
    uHighColor: new THREE.Color(0x66ccff), // Default Lighter blue for crests
    uWaveIntensity: 0.008, // Adjusted default intensity for small sphere
    uWaveFrequency: 30.0, // Adjusted default base spatial frequency for small sphere
    uWaveSpeed: 0.25, // Adjusted default animation speed
  },
  vertexShader, // Vertex Shader
  fragmentShader // Fragment Shader
);

// Extend Three.js to include this material
extend({ WaterMaterial });

export const Earth2 = forwardRef((props, ref) => {
  const { nodes, materials } = useGLTF(modelUrl);
  const oceanTexture = useTexture("/seamless_ocean.png");
  const sphereRef = useRef(); // Create a ref for the sphere mesh
  const waterMaterialRef = useRef(); // Ref for the custom material

  const shaderControls = useControls("Ocean Shader", {
    lowColor: { value: "#c1e0ff", label: "Low Color" },
    highColor: { value: "#66ccff", label: "High Color" },
    waveIntensity: {
      value: 0.008, // Matched new default
      min: 0.0005, // Lowered min for finer control on small scales
      max: 0.03, // Adjusted max intensity
      step: 0.0001, // Finer step
      label: "Intensity",
    },
    waveFrequency: {
      // This is now the base spatial frequency
      value: 30.0, // Matched new default
      min: 5.0, // Adjusted range for small sphere visibility
      max: 150.0, // Increased max for more detail potential
      step: 0.1,
      label: "Frequency",
    },
    waveSpeed: {
      value: 0.25, // Matched new default
      min: 0.01, // Adjusted range
      max: 1.5,
      step: 0.01,
      label: "Speed",
    },
  });

  // Configure texture repetition
  useEffect(() => {
    if (oceanTexture) {
      oceanTexture.wrapS = THREE.RepeatWrapping;
      oceanTexture.wrapT = THREE.RepeatWrapping;
      oceanTexture.repeat.set(4, 4); // Repeat 4 times horizontally, 2 times vertically
      oceanTexture.needsUpdate = true; // Important: notify Three.js the texture has changed
    }
  }, [oceanTexture]); // Re-run effect if oceanTexture changes

  // Use useFrame to update the sphere's rotation each frame
  useFrame((state, delta) => {
    if (sphereRef.current) {
      // Example: Rotate the sphere around the Y axis
      // sphereRef.current.rotation.y += delta * 0.01; // Adjust speed as needed
    }
    if (waterMaterialRef.current) {
      waterMaterialRef.current.uTime += delta;
      // Leva controls will update uniforms directly if props are passed
    }
  });

  return (
    <group ref={ref} {...props} dispose={null}>
      {/* Assign the ref to the sphere mesh */}
      <mesh
        name="ocean"
        ref={sphereRef}
        rotation={[-0.1, 0.9, -1.0]}
        scale={1.85}
      >
        <sphereGeometry args={[1.023, 640, 640]} />
        {/* Ensure the texture is passed to the material */}
        {/* <meshStandardMaterial map={oceanTexture} /> */}
        <waterMaterial
          ref={waterMaterialRef}
          uLowColor={shaderControls.lowColor}
          uHighColor={shaderControls.highColor}
          uWaveIntensity={shaderControls.waveIntensity}
          uWaveFrequency={shaderControls.waveFrequency}
          uWaveSpeed={shaderControls.waveSpeed}
        />
      </mesh>

      <mesh
        name="continent"
        geometry={nodes["optimized-verts"].geometry}
        material={materials["Material.001"]}
        position={[0.047, 0.021, 0]}
        rotation={[-Math.PI / 2, 0, -0.1]}
        scale={[1.221, 1.213, 1.214]}
      />
    </group>
  );
});

useGLTF.preload(modelUrl);
