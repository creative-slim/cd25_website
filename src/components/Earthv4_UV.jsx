/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/earthv4_UV.glb --transform
Files: ./public/earthv4_UV.glb [356.76KB] > /Users/slim-cd/Documents/_Projects/__Creative Directors Website/website 2025/react-3D/cd25_website/earthv4_UV-transformed.glb [30.93KB] (91%)
*/

import React, { useRef, useMemo, useEffect } from "react"; // Import useEffect
import { useGLTF, useTexture, shaderMaterial } from "@react-three/drei"; // Import shaderMaterial
import { useFrame, extend } from "@react-three/fiber"; // Import extend
import * as THREE from "three";
import { Suspense } from "react";
import { forwardRef, useImperativeHandle } from "react";
import { useControls } from "leva"; // Import useControls

// Determine the model URL based on the environment
const isDevelopment = import.meta.env.DEV;
const localModelUrl = "src/models/earth_final-transformed.glb";
const remoteModelUrl =
  "https://files.creative-directors.com/creative-website/creative25/glbs/earth_final-transformed.glb"; // Corrected remote URL if needed
const modelUrl = isDevelopment ? localModelUrl : remoteModelUrl;

console.log(`Loading model from: ${modelUrl}`); // Log which URL is being used

// Define the NEW shaders from scratch
const newVertexShader = `
  uniform float uTime;
  uniform float uNoiseIntensity;
  uniform float uNoiseFrequency;
  uniform float uNoiseSpeed;

  varying float vWaveHeight;

  // Simplex 3D Noise 
  // by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)
  // Helper functions for snoise(vec3)
  vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

  float snoise(vec3 v) {
    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);

    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

    // Permutations
    i = mod(i, 289.0);
    vec4 p = permute(permute(permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0));

    // Gradients: N*N points uniformly over a square, mapped onto an octahedron.
    // N=7, n_ = 1.0/N
    float n_ = 1.0 / 7.0;
    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p, N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_); // mod(j, N)

    vec4 x = x_ * ns.x + ns.yyyy;
    vec4 y = y_ * ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);

    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);

    // Normalise gradients
    vec4 normVal = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
    p0 *= normVal.x;
    p1 *= normVal.y;
    p2 *= normVal.z;
    p3 *= normVal.w;

    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
  }

  void main() {
    vec3 objectPosition = position; 
    float time = uTime * uNoiseSpeed;
    
    vec3 noiseInput = objectPosition * uNoiseFrequency;
    noiseInput.z += time; 

    float noiseValue = snoise(noiseInput);
    
    vec3 displacedPosition = objectPosition + normalize(normal) * noiseValue * uNoiseIntensity;
    
    vWaveHeight = (noiseValue + 1.0) * 0.5; 
    vWaveHeight = clamp(vWaveHeight, 0.0, 1.0);

    gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
  }
`;

const newFragmentShader = `
  uniform vec3 uLowColor;
  uniform vec3 uHighColor;

  varying float vWaveHeight;

  void main() {
    vec3 color = mix(uLowColor, uHighColor, vWaveHeight);
    gl_FragColor = vec4(color, 1.0);
  }
`;

// Create a new custom material using shaderMaterial
const NewWaterMaterial = shaderMaterial(
  {
    uTime: 0,
    uLowColor: new THREE.Color(0x000033), // Deep blue
    uHighColor: new THREE.Color(0x66ccff), // Lighter blue
    uNoiseIntensity: 0.01,
    uNoiseFrequency: 20.0,
    uNoiseSpeed: 0.1,
  },
  newVertexShader,
  newFragmentShader
);

// Extend Three.js to include this material
extend({ NewWaterMaterial }); // Use a different name if WaterMaterial is still in use elsewhere or remove the old one

export const Earth2 = forwardRef((props, ref) => {
  const { nodes, materials } = useGLTF(modelUrl);
  // const oceanTexture = useTexture("/seamless_ocean.png"); // Not used in the new shader
  // const matcapTexture = useTexture("/matcap_ocean.png"); // Not used in the new shader
  const sphereRef = useRef();
  const waterMaterialRef = useRef();

  const shaderControls = useControls("Ocean Shader", {
    lowColor: { value: "#5e5eff", label: "Low Color" },
    highColor: { value: "#66ccff", label: "High Color" },
    noiseIntensity: {
      value: 0.01,
      min: 0.001,
      max: 0.1,
      step: 0.001,
      label: "Noise Intensity",
    },
    noiseFrequency: {
      value: 20.0,
      min: 1.0,
      max: 100.0,
      step: 0.1,
      label: "Noise Frequency",
    },
    noiseSpeed: {
      value: 0.1,
      min: 0.0,
      max: 1.0,
      step: 0.01,
      label: "Noise Speed",
    },
    // Remove old controls if they are no longer relevant
    // waveIntensity: false,
    // waveFrequency: false,
    // waveSpeed: false,
    // simplexIntensity: false,
    // simplexFrequency: false,
    // simplexSpeed: false,
    // perlinIntensity: false,
    // perlinFrequency: false,
    // perlinSpeed: false,
    // matcapMixFactor: false,
  });

  // useEffect(() => { // Old texture setup, not needed for new shader
  //   if (oceanTexture) {
  //     oceanTexture.wrapS = THREE.RepeatWrapping;
  //     oceanTexture.wrapT = THREE.RepeatWrapping;
  //     oceanTexture.repeat.set(4, 4);
  //     oceanTexture.needsUpdate = true;
  //   }
  // }, [oceanTexture]);

  useFrame((state, delta) => {
    if (waterMaterialRef.current) {
      waterMaterialRef.current.uTime += delta;
    }
  });

  return (
    <group ref={ref} {...props} dispose={null}>
      <mesh
        name="ocean"
        ref={sphereRef}
        rotation={[-0.1, 0.9, -1.0]} // Keep existing rotation if desired
        scale={1.85} // Keep existing scale if desired
      >
        <sphereGeometry args={[1.023, 128 * 4, 128 * 4]} />
        {/* Increased segments for smoother noise, adjust as needed */}
        <newWaterMaterial
          ref={waterMaterialRef}
          uLowColor={shaderControls.lowColor}
          uHighColor={shaderControls.highColor}
          uNoiseIntensity={shaderControls.noiseIntensity}
          uNoiseFrequency={shaderControls.noiseFrequency}
          uNoiseSpeed={shaderControls.noiseSpeed}
        />
      </mesh>

      <mesh
        name="continent"
        geometry={nodes["optimized-verts"].geometry}
        material={materials["Material.001"]}
        position={[0.047, 0.021, 0]}
        rotation={[-Math.PI / 2, 0, -0.1]}
        scale={[1.221, 1.213, 1.214]}
      />
    </group>
  );
});

useGLTF.preload(modelUrl);
