/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/Kreaton_A.glb --transform 
Files: ./public/Kreaton_A.glb [10.88MB] > /Users/slim-cd/Documents/_Projects/__Creative Directors Website/website 2025/react-3D/cd25_website/Kreaton_A-transformed.glb [724.45KB] (93%)
*/

import { useFrame, useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import {
  playAnimationTransition,
  getCurrentAnimations,
  stopAllAnimations,
  resetAnimationState,
} from "../utils/animationUtils";
import { forwardRef } from "react";
import { useImperativeHandle, useRef, useMemo, useEffect } from "react";
// import { NodeToyMaterial, NodeToyTick } from "@nodetoy/react-nodetoy";
import { NodeToyMaterial } from "@nodetoy/three-nodetoy";
import { kreatonGoldMaterial } from "../materials/kreatonGoldMaterial";
import { kreatonArmorMaterial } from "../materials/kreatonWhiteArmorMaterial";

export const Kreaton = forwardRef((props, ref) => {
  const internalRef = useRef();
  const { scene, animations } = useGLTF(
    "src/models/KreatonUV3-transformed.glb"
  );
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);

  const skinMaterial = new NodeToyMaterial({
    url: "https://draft.nodetoy.co/cVZ6s0mHJroEdc8m",
  });
  materials.Skin = skinMaterial;
  materials.gold = kreatonGoldMaterial;
  materials.white = kreatonArmorMaterial;

  const { actions } = useAnimations(animations, internalRef);

  // Define what to expose to parent components through the ref
  useImperativeHandle(ref, () => {
    // Create an instance to access our own methods inside other methods
    const instance = {
      // Expose all available actions for flexibility
      actions,

      // Get the current playing animation name
      getCurrentAnimation: () => {
        const playing = getCurrentAnimations(actions);
        return playing.length > 0 ? playing[0].name : null;
      },

      // Specific animation control methods
      playAnimation: (name, options = {}) => {
        const action = actions[name];
        if (action) {
          action
            .reset()
            .fadeIn(options.fadeIn || 0.5)
            .play();
          return true;
        }
        console.warn(`Animation "${name}" not found`);
        return false;
      },

      stopAnimation: (name, options = {}) => {
        const action = actions[name];
        if (action) {
          action.fadeOut(options.fadeOut || 0.5);
          return true;
        }
        return false;
      },

      transitionAnimation: (fromName, toName, options = {}) => {
        return playAnimationTransition(
          actions,
          actions[toName],
          {
            crossFadeTime: options.crossFadeTime || 0.5,
            fadeInDuration: options.fadeInDuration || 0.2,
          },
          actions[fromName]
        );
      },

      // Transition from any currently playing animation to the target animation
      transitionFromCurrentToAnimation: (toName, options = {}) => {
        // Use our own getCurrentAnimation method instead of the external function
        const currentAnimationName = instance.getCurrentAnimation();

        // Still log details for debugging purposes
        console.log("Animation detection debug:");
        console.log("- Using getCurrentAnimation:", currentAnimationName);
        console.log(
          "- Raw getCurrentAnimations:",
          getCurrentAnimations(actions).map((a) => a.name)
        );
        console.log(
          "- Animations with weight > 0:",
          Object.entries(actions)
            .filter(([_, action]) => action.weight > 0)
            .map(([name]) => `${name} (${actions[name].weight.toFixed(2)})`)
        );

        // If current animation is the same as target, do nothing
        if (currentAnimationName === toName) {
          console.log(
            `Already playing "${toName}" animation - no transition needed`
          );
          return true;
        }

        if (!currentAnimationName) {
          // If no animation is currently playing, clean up and start fresh
          console.log(`No current animation detected, playing: ${toName}`);

          // Reset all animation state first to clean up
          resetAnimationState(actions);

          const action = actions[toName];
          if (action) {
            action.enabled = true;
            action.weight = 1;
            action
              .reset()
              .fadeIn(options.fadeIn || 0.5)
              .play();
            return true;
          }
          console.warn(`Animation "${toName}" not found`);
          return false;
        }

        console.log(`Transitioning from ${currentAnimationName} to ${toName}`);

        // Full reset of all other animations to clean the state
        stopAllAnimations(
          actions,
          [actions[toName], actions[currentAnimationName]],
          true
        );

        // Simple transition - stop current, start new
        const currentAction = actions[currentAnimationName];
        const toAction = actions[toName];

        if (currentAction && toAction) {
          currentAction.fadeOut(options.crossFadeTime || 0.5);

          toAction.enabled = true;
          toAction.weight = 1;
          toAction.reset();
          toAction.fadeIn(options.fadeInDuration || 0.2);
          toAction.play();
          return true;
        }

        console.warn(`Target animation "${toName}" not found`);
        return false;
      },

      // List available animations
      getAnimationNames: () => Object.keys(actions),

      // Access to the mesh for other operations
      getObject: () => internalRef.current,
    };

    return instance;
  });

  useEffect(() => {
    console.log("Available animations:", animations);
    console.log("Available actions:", actions);
    console.log("Action keys:", Object.keys(actions));

    nodes.mixamorigHips.children[0].children[0].children[0].children[0].children[0].children[1].children[2].material =
      skinMaterial;
    nodes.mixamorigHips.children[0].children[0].children[0].children[0].children[0].children[1].children[1].material =
      kreatonGoldMaterial;

    nodes.mixamorigHips.children[0].children[0].children[0].children[0].children[0].children[1].children[0].material =
      kreatonArmorMaterial;

    // Animation setup code...
  }, [actions, animations, playAnimationTransition]);

  useFrame(() => {
    // Update the material properties or perform any other operations here
    // For example, you can update the skinMaterial properties if needed
    NodeToyMaterial.tick();
  });

  return (
    <group ref={internalRef} {...props} dispose={null}>
      <group name="Scene">
        <group name="Kreaton_Rigged">
          <primitive object={nodes.mixamorigHips} />
        </group>
        <group name="Arms001">
          <skinnedMesh
            name="Armsmesh"
            geometry={nodes.Armsmesh.geometry}
            material={materials.white}
            skeleton={nodes.Armsmesh.skeleton}
          />
          <skinnedMesh
            name="Armsmesh_1"
            geometry={nodes.Armsmesh_1.geometry}
            material={materials.gold}
            skeleton={nodes.Armsmesh_1.skeleton}
          />
          <skinnedMesh
            name="Armsmesh_2"
            geometry={nodes.Armsmesh_2.geometry}
            material={materials.Skin}
            skeleton={nodes.Armsmesh_2.skeleton}
          />
        </group>
        <group name="FeetLegs001">
          <skinnedMesh
            name="FeetLegsmesh"
            geometry={nodes.FeetLegsmesh.geometry}
            material={materials.white}
            skeleton={nodes.FeetLegsmesh.skeleton}
          />
          <skinnedMesh
            name="FeetLegsmesh_1"
            geometry={nodes.FeetLegsmesh_1.geometry}
            material={materials.gold}
            skeleton={nodes.FeetLegsmesh_1.skeleton}
          />
          <skinnedMesh
            name="FeetLegsmesh_2"
            geometry={nodes.FeetLegsmesh_2.geometry}
            material={materials.Skin}
            skeleton={nodes.FeetLegsmesh_2.skeleton}
          />
        </group>
        <group name="Skirt001">
          <skinnedMesh
            name="Skirtmesh"
            geometry={nodes.Skirtmesh.geometry}
            material={materials.white}
            skeleton={nodes.Skirtmesh.skeleton}
          />
          <skinnedMesh
            name="Skirtmesh_1"
            geometry={nodes.Skirtmesh_1.geometry}
            material={materials.gold}
            skeleton={nodes.Skirtmesh_1.skeleton}
          />
        </group>
        <group name="TorsoArmor001">
          <skinnedMesh
            name="TorsoArmormesh"
            geometry={nodes.TorsoArmormesh.geometry}
            material={materials.white}
            skeleton={nodes.TorsoArmormesh.skeleton}
          />
          <skinnedMesh
            name="TorsoArmormesh_1"
            geometry={nodes.TorsoArmormesh_1.geometry}
            material={materials.gold}
            skeleton={nodes.TorsoArmormesh_1.skeleton}
          />
          <skinnedMesh
            name="TorsoArmormesh_2"
            geometry={nodes.TorsoArmormesh_2.geometry}
            material={materials.Skin}
            skeleton={nodes.TorsoArmormesh_2.skeleton}
          />
        </group>
      </group>
    </group>
  );
});

useGLTF.preload("src/models/KreatonUV3-transformed.glb");
