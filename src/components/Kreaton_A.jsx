/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/Kreaton_A.glb --transform 
Files: ./public/Kreaton_A.glb [10.88MB] > /Users/slim-cd/Documents/_Projects/__Creative Directors Website/website 2025/react-3D/cd25_website/Kreaton_A-transformed.glb [724.45KB] (93%)
*/

import { useFrame, useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import { LoopOnce, LoopRepeat } from "three"; // Import LoopOnce and LoopRepeat
import {
  playAnimationTransition,
  getCurrentAnimations,
  stopAllAnimations,
  resetAnimationState,
} from "../utils/animationUtils";
import { forwardRef } from "react";
import { useImperativeHandle, useRef, useMemo, useEffect } from "react";
// import { NodeToyMaterial, NodeToyTick } from "@nodetoy/react-nodetoy";
import { NodeToyMaterial } from "@nodetoy/three-nodetoy";
import { kreatonGoldMaterial } from "../materials/kreatonGoldMaterial";
import { kreatonArmorMaterial } from "../materials/kreatonWhiteArmorMaterial";

// Determine the model URL based on the environment
const isDevelopment = import.meta.env.DEV;
const localModelUrl = "src/models/Kreaton_final-transformed.glb";
const remoteModelUrl =
  "http://files.creative-directors.com/creative-website/creative25/glbs/Kreaton_final-transformed.glb"; // Corrected remote URL if needed
const modelUrl = isDevelopment ? localModelUrl : remoteModelUrl;

console.log(`Loading model from: ${modelUrl}`); // Log which URL is being used

export const Kreaton = forwardRef((props, ref) => {
  // Remove local/remote definitions here as they are now outside the component

  const internalRef = useRef();
  // Use the determined modelUrl
  const { scene, animations } = useGLTF(modelUrl);
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);

  const skinMaterial = new NodeToyMaterial({
    url: "https://draft.nodetoy.co/cVZ6s0mHJroEdc8m",
  });
  materials.Skin = skinMaterial;
  materials.gold = kreatonGoldMaterial;
  materials.white = kreatonArmorMaterial;

  const { actions, mixer } = useAnimations(animations, internalRef); // Get mixer

  // Define what to expose to parent components through the ref
  useImperativeHandle(ref, () => {
    // Create an instance to access our own methods inside other methods
    const instance = {
      // Expose all available actions for flexibility
      actions,

      // Get the current playing animation name
      getCurrentAnimation: () => {
        const playing = getCurrentAnimations(actions);
        return playing.length > 0 ? playing[0].name : null;
      },

      // Specific animation control methods
      playAnimation: (name, options = {}) => {
        const action = actions[name];
        if (action) {
          action
            .reset()
            .fadeIn(options.fadeIn || 0.5)
            .play();
          return true;
        }
        console.warn(`Animation "${name}" not found`);
        return false;
      },

      stopAnimation: (name, options = {}) => {
        const action = actions[name];
        if (action) {
          // Ensure the action stops gracefully before fading out
          action.stop(); // Add this line to stop the animation immediately
          action.fadeOut(options.fadeOut || 0.5);
          // Optionally reset after fade out completes if needed, though fadeOut usually handles this
          // setTimeout(() => action.reset(), (options.fadeOut || 0.5) * 1000);
          return true;
        }
        return false;
      },

      transitionAnimation: (fromName, toName, options = {}) => {
        return playAnimationTransition(
          actions,
          actions[toName],
          {
            crossFadeTime: options.crossFadeTime || 0.5,
            fadeInDuration: options.fadeInDuration || 0.2,
          },
          actions[fromName]
        );
      },

      // Transition from any currently playing animation to the target animation
      transitionFromCurrentToAnimation: (toName, options = {}) => {
        // Use our own getCurrentAnimation method instead of the external function
        const currentAnimationName = instance.getCurrentAnimation();
        const loopOnce = options.loopOnce || false; // Get loopOnce option
        const onComplete = options.onComplete; // Get onComplete callback

        // Still log details for debugging purposes
        console.log("Animation detection debug:");
        console.log("- Using getCurrentAnimation:", currentAnimationName);
        console.log(
          "- Raw getCurrentAnimations:",
          getCurrentAnimations(actions).map((a) => a.name)
        );
        console.log(
          "- Animations with weight > 0:",
          Object.entries(actions)
            .filter(([_, action]) => action.weight > 0)
            .map(([name]) => `${name} (${actions[name].weight.toFixed(2)})`)
        );

        // If current animation is the same as target, do nothing (unless forcing restart or loop change)
        if (currentAnimationName === toName && !options.forceRestart) {
          const action = actions[toName];
          // Check if loop mode needs updating
          if (action && loopOnce && action.loop !== LoopOnce) {
            console.log(`Updating loop mode for "${toName}" to LoopOnce.`);
            action.setLoop(LoopOnce, 1);
            action.clampWhenFinished = true;
            // Add listener if onComplete is provided
            if (onComplete) {
              const listener = (event) => {
                if (event.action === action) {
                  console.log(`LoopOnce animation "${toName}" completed.`);
                  onComplete();
                  mixer.removeEventListener("finished", listener);
                }
              };
              mixer.addEventListener("finished", listener);
            }
          } else if (action && !loopOnce && action.loop !== LoopRepeat) {
            console.log(`Updating loop mode for "${toName}" to LoopRepeat.`);
            action.setLoop(LoopRepeat);
            action.clampWhenFinished = false;
          } else {
            console.log(
              `Already playing "${toName}" animation - no transition needed`
            );
          }
          return true;
        }

        if (!currentAnimationName) {
          // If no animation is currently playing, clean up and start fresh
          console.log(`No current animation detected, playing: ${toName}`);

          // Reset all animation state first to clean up
          resetAnimationState(actions);

          const action = actions[toName];
          if (action) {
            action.enabled = true;
            action.weight = 1;
            action.reset();
            if (loopOnce) {
              action.setLoop(LoopOnce, 1);
              action.clampWhenFinished = true;
              console.log(`Playing "${toName}" once.`);
              // Add listener if onComplete is provided
              if (onComplete) {
                const listener = (event) => {
                  if (event.action === action) {
                    console.log(`LoopOnce animation "${toName}" completed.`);
                    onComplete();
                    mixer.removeEventListener("finished", listener);
                  }
                };
                // Remove previous listeners for safety before adding new one
                mixer.removeEventListener("finished", listener);
                mixer.addEventListener("finished", listener);
              }
            } else {
              action.setLoop(LoopRepeat); // Ensure it loops normally if not loopOnce
              action.clampWhenFinished = false;
              console.log(`Playing "${toName}" on loop.`);
            }
            action.fadeIn(options.fadeInDuration || 0.2).play(); // Use fadeInDuration
            return true;
          }
          console.warn(`Animation "${toName}" not found`);
          return false;
        }

        console.log(`Transitioning from ${currentAnimationName} to ${toName}`);

        // Full reset of all other animations to clean the state
        stopAllAnimations(
          actions,
          [actions[toName], actions[currentAnimationName]],
          true
        );

        // Simple transition - stop current, start new
        const currentAction = actions[currentAnimationName];
        const toAction = actions[toName];

        if (currentAction && toAction) {
          currentAction.fadeOut(options.crossFadeTime || 0.5);

          toAction.enabled = true;
          toAction.weight = 1;
          toAction.reset();
          if (loopOnce) {
            toAction.setLoop(LoopOnce, 1);
            toAction.clampWhenFinished = true;
            console.log(`Transitioning to "${toName}" once.`);
            // Add listener if onComplete is provided
            if (onComplete) {
              const listener = (event) => {
                if (event.action === toAction) {
                  console.log(`LoopOnce animation "${toName}" completed.`);
                  onComplete();
                  mixer.removeEventListener("finished", listener);
                }
              };
              // Remove previous listeners for safety before adding new one
              mixer.removeEventListener("finished", listener);
              mixer.addEventListener("finished", listener);
            }
          } else {
            toAction.setLoop(LoopRepeat); // Ensure it loops normally if not loopOnce
            toAction.clampWhenFinished = false;
            console.log(`Transitioning to "${toName}" on loop.`);
          }
          toAction.fadeIn(options.fadeInDuration || 0.2); // Use fadeInDuration
          toAction.play();
          return true;
        }

        console.warn(
          `Animation transition failed: Current="${currentAnimationName}", Target="${toName}"`
        );
        return false;
      },

      // List available animations
      getAnimationNames: () => Object.keys(actions),

      // Access to the mesh for other operations
      getObject: () => internalRef.current,
    };

    return instance;
  });

  useEffect(() => {
    console.log("Available animations:", animations);
    console.log("Available actions:", actions);
    console.log("Action keys:", Object.keys(actions));

    nodes.mixamorigHips.children[0].children[0].children[0].children[0].children[0].children[1].children[2].material =
      skinMaterial;
    nodes.mixamorigHips.children[0].children[0].children[0].children[0].children[0].children[1].children[1].material =
      kreatonGoldMaterial;

    nodes.mixamorigHips.children[0].children[0].children[0].children[0].children[0].children[1].children[0].material =
      kreatonArmorMaterial;

    // Animation setup code...
  }, [actions, animations, playAnimationTransition]);

  useFrame(() => {
    // Update the material properties or perform any other operations here
    // For example, you can update the skinMaterial properties if needed
    NodeToyMaterial.tick();
  });

  return (
    <group ref={internalRef} {...props} dispose={null}>
      <group name="Scene">
        <group name="Kreaton_Rigged">
          <primitive object={nodes.mixamorigHips} />
        </group>
        <group name="Arms001">
          <skinnedMesh
            name="Armsmesh"
            geometry={nodes.Armsmesh.geometry}
            material={materials.white}
            skeleton={nodes.Armsmesh.skeleton}
          />
          <skinnedMesh
            name="Armsmesh_1"
            geometry={nodes.Armsmesh_1.geometry}
            material={materials.gold}
            skeleton={nodes.Armsmesh_1.skeleton}
          />
          <skinnedMesh
            name="Armsmesh_2"
            geometry={nodes.Armsmesh_2.geometry}
            material={materials.Skin}
            skeleton={nodes.Armsmesh_2.skeleton}
          />
        </group>
        <group name="FeetLegs001">
          <skinnedMesh
            name="FeetLegsmesh"
            geometry={nodes.FeetLegsmesh.geometry}
            material={materials.white}
            skeleton={nodes.FeetLegsmesh.skeleton}
          />
          <skinnedMesh
            name="FeetLegsmesh_1"
            geometry={nodes.FeetLegsmesh_1.geometry}
            material={materials.gold}
            skeleton={nodes.FeetLegsmesh_1.skeleton}
          />
          <skinnedMesh
            name="FeetLegsmesh_2"
            geometry={nodes.FeetLegsmesh_2.geometry}
            material={materials.Skin}
            skeleton={nodes.FeetLegsmesh_2.skeleton}
          />
        </group>
        <group name="Skirt001">
          <skinnedMesh
            name="Skirtmesh"
            geometry={nodes.Skirtmesh.geometry}
            material={materials.white}
            skeleton={nodes.Skirtmesh.skeleton}
          />
          <skinnedMesh
            name="Skirtmesh_1"
            geometry={nodes.Skirtmesh_1.geometry}
            material={materials.gold}
            skeleton={nodes.Skirtmesh_1.skeleton}
          />
        </group>
        <group name="TorsoArmor001">
          <skinnedMesh
            name="TorsoArmormesh"
            geometry={nodes.TorsoArmormesh.geometry}
            material={materials.white}
            skeleton={nodes.TorsoArmormesh.skeleton}
          />
          <skinnedMesh
            name="TorsoArmormesh_1"
            geometry={nodes.TorsoArmormesh_1.geometry}
            material={materials.gold}
            skeleton={nodes.TorsoArmormesh_1.skeleton}
          />
          <skinnedMesh
            name="TorsoArmormesh_2"
            geometry={nodes.TorsoArmormesh_2.geometry}
            material={materials.Skin}
            skeleton={nodes.TorsoArmormesh_2.skeleton}
          />
        </group>
      </group>
    </group>
  );
});

// Use the determined modelUrl for preloading
useGLTF.preload(modelUrl);
